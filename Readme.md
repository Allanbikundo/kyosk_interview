# Kyosk Interview Project

## Table of Contents

- [Overview](#overview)
- [Technologies Used](#technologies-used)
- [Steps to Build and Run Locally (Using Docker)](#steps-to-build-and-run-locally-using-docker)
- [Steps to Deploy on Minikube](#steps-to-deploy-on-minikube)
  - [Required Minikube Setup Commands](#required-minikube-setup-commands)
  - [Deploying the Application](#deploying-the-application)
  - [Accessing the Application](#accessing-the-application)
- [CI/CD Pipeline Explanation](#cicd-pipeline-explanation)
- [Decisions, Assumptions, and Challenges Faced](#decisions-assumptions-and-challenges-faced)

---

## Overview

This project demonstrates a containerized backend and frontend application deployed to a Kubernetes cluster. It includes:

- **Backend**: A Spring Boot application with MongoDB integration.
- **Frontend**: A React-based application that interacts with the backend.
- CI/CD pipeline to build, push Docker images to GitHub Container Registry (GHCR), and automate deployments.

---

## Technologies Used

- **Backend**: Spring Boot (Java) with MongoDB
- **Frontend**: React
- **Containerization**: Docker
- **Orchestration**: Kubernetes (Minikube)
- **CI/CD**: GitHub Actions
- **Container Registry**: GitHub Container Registry (GHCR)

---

## Steps to Build and Run Locally (Using Docker)

### Prerequisites

- Docker installed on your local machine.
- MongoDB accessible locally or running as a container.

head to the root directory and run 

```bash
 docker-compose -f docker-compose.local.yaml up --build
```

### Access the Application

- **Backend**: `http://localhost:8081/backend`
- **Frontend**: `http://localhost:3000`

---

## Steps to Deploy on Minikube

### Required Minikube Setup Commands

1. Start Minikube:
   ```bash
   minikube start
   ```
2. Verify Minikube status:
   ```bash
   minikube status
   ```
3. Set Docker environment to use Minikube:
   ```bash
   eval $(minikube docker-env)
   ```

### Deploying the Application

1. Navigate to the directory containing the Kubernetes manifests (generated by `kompose`):
   ```bash
   cd ./helm-charts
   ```
2. Apply the manifests:
   ```bash
   kubectl apply -f .
   ```

### Accessing the Application

1. **Check Services**:
   ```bash
   kubectl get services
   ```
2. If using `NodePort`, access the application using Minikube's IP:

   ```bash
   minikube ip
   ```

   - **Backend**: `http://<minikube-ip>:<backend-nodeport>`
   - **Frontend**: `http://<minikube-ip>:<frontend-nodeport>`

3. Alternatively, use Minikubeâ€™s service command:
   ```bash
   minikube service backend
   minikube service frontend
   ```

---

## CI/CD Pipeline Explanation

The GitHub Actions pipeline is designed to:

1. **Trigger**:
   - On every push or pull request to the `main` branch.
2. **Build Docker Images**:
   - Builds Docker images for the backend and frontend using the respective `Dockerfile`.
3. **Push to GHCR**:
   - Tags and pushes the Docker images to GitHub Container Registry (GHCR).
4. **Workflow YAML**:
   - The pipeline is defined in `.github/workflows/docker-build-and-push.yml`.

### Key Steps in the Workflow

1. **Checkout the Code**:
   Uses `actions/checkout` to fetch the latest code.
2. **Login to GHCR**:
   Authenticates with GHCR using the GitHub-provided `GITHUB_TOKEN`.
3. **Build and Push Backend and Frontend**:
   Uses `docker build` and `docker push` commands for both backend and frontend images.

---

## Decisions, Assumptions, and Challenges Faced

### Decisions

1. Used `NodePort` for external access in Minikube.
2. Leveraged `kompose` for converting `docker-compose.yml` into Kubernetes manifests for faster setup.

### Assumptions

1. MongoDB is accessible within the Kubernetes cluster (via `mongo` service).
2. The frontend and backend are configured to work on predefined ports (`3000` and `8081`).

### Challenges Faced

1. **ImagePullBackOff**: Encountered due to missing GHCR authentication. Resolved by adding a `docker-registry` secret.
2. **CORS Issues**: Resolved by enabling CORS in the backend for React-based frontend communication.

---

## Future Improvements

- Automate Kubernetes deployment in the CI/CD pipeline.
- Add Helm charts for more robust and configurable deployments.
- Use `Ingress` for better routing and load balancing in Minikube.

